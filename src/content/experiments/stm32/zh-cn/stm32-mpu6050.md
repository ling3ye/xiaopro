---
title: "STM32 读取 MPU6050 姿态数据"
boardId: "stm32f4"
moduleId: "sensor/mpu6050"
date: 2024-01-25
intro: "学习 STM32 的 I2C 通信，读取 6 轴运动传感器的加速度和角速度数据。"
---

## 实验简介

MPU6050 是一款集成了 3 轴加速度计和 3 轴陀螺仪的运动传感器。本实验将学习如何使用 STM32 的 I2C 外设读取 MPU6050 的原始数据。

## 硬件连接

| MPU6050 引脚 | STM32F4 引脚 |
|--------------|--------------|
| VDD          | 3.3V         |
| GND          | GND          |
| SCL          | PB6 (I2C1_SCL)|
| SDA          | PB7 (I2C1_SDA)|
| AD0          | GND          |

**注意**：AD0 接 GND 时 I2C 地址为 0x68，接 VDD 时为 0x69。

## 寄存器定义

```c
#define MPU6050_ADDR          0xD0  // 8位写地址 (0x68 << 1)
#define MPU6050_REG_SMPLRT_DIV 0x19
#define MPU6050_REG_CONFIG     0x1A
#define MPU6050_REG_GYRO_CONFIG 0x1B
#define MPU6050_REG_ACCEL_CONFIG 0x1C
#define MPU6050_REG_ACCEL_XOUT_H 0x3B
#define MPU6050_REG_PWR_MGMT_1  0x6B
#define MPU6050_REG_WHO_AM_I    0x75
```

## 初始化代码

```c
#include "stm32f4xx_hal.h"

I2C_HandleTypeDef hi2c1;

// MPU6050 数据结构
typedef struct {
    int16_t accel_x;
    int16_t accel_y;
    int16_t accel_z;
    int16_t gyro_x;
    int16_t gyro_y;
    int16_t gyro_z;
} MPU6050_Data;

// 写寄存器
HAL_StatusTypeDef MPU6050_WriteReg(uint8_t reg, uint8_t value) {
    return HAL_I2C_Mem_Write(&hi2c1, MPU6050_ADDR, reg, I2C_MEMADD_SIZE_8BIT, &value, 1, HAL_MAX_DELAY);
}

// 读寄存器
HAL_StatusTypeDef MPU6050_ReadReg(uint8_t reg, uint8_t *value) {
    return HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, reg, I2C_MEMADD_SIZE_8BIT, value, 1, HAL_MAX_DELAY);
}

// 读取全部数据
HAL_StatusTypeDef MPU6050_ReadData(MPU6050_Data *data) {
    uint8_t buffer[14];
    HAL_StatusTypeDef status;

    // 从 ACCEL_XOUT_H 开始读取 14 字节
    status = HAL_I2C_Mem_Read(&hi2c1, MPU6050_ADDR, MPU6050_REG_ACCEL_XOUT_H,
                             I2C_MEMADD_SIZE_8BIT, buffer, 14, HAL_MAX_DELAY);

    if (status == HAL_OK) {
        data->accel_x = (int16_t)(buffer[0] << 8 | buffer[1]);
        data->accel_y = (int16_t)(buffer[2] << 8 | buffer[3]);
        data->accel_z = (int16_t)(buffer[4] << 8 | buffer[5]);
        // 跳过温度数据
        data->gyro_x  = (int16_t)(buffer[8] << 8 | buffer[9]);
        data->gyro_y  = (int16_t)(buffer[10] << 8 | buffer[11]);
        data->gyro_z  = (int16_t)(buffer[12] << 8 | buffer[13]);
    }

    return status;
}

// 初始化 MPU6050
void MPU6050_Init(void) {
    // 退出睡眠模式
    MPU6050_WriteReg(MPU6050_REG_PWR_MGMT_1, 0x00);
    HAL_Delay(100);

    // 配置采样率：1kHz / (1 + 7) = 125Hz
    MPU6050_WriteReg(MPU6050_REG_SMPLRT_DIV, 0x07);

    // 配置数字低通滤波器
    MPU6050_WriteReg(MPU6050_REG_CONFIG, 0x00);

    // 陀螺仪满量程 ±2000°/s
    MPU6050_WriteReg(MPU6050_REG_GYRO_CONFIG, 0x18);

    // 加速度计满量程 ±16g
    MPU6050_WriteReg(MPU6050_REG_ACCEL_CONFIG, 0x18);
}
```

## 主程序

```c
int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_I2C1_Init();

    MPU6050_Data sensor_data;

    // 初始化传感器
    MPU6050_Init();

    while (1) {
        if (MPU6050_ReadData(&sensor_data) == HAL_OK) {
            // 打印原始数据
            printf("Accel: X=%d, Y=%d, Z=%d\n",
                   sensor_data.accel_x, sensor_data.accel_y, sensor_data.accel_z);
            printf("Gyro: X=%d, Y=%d, Z=%d\n",
                   sensor_data.gyro_x, sensor_data.gyro_y, sensor_data.gyro_z);
        }

        HAL_Delay(100);
    }
}
```

## 数据转换

### 加速度转换
```c
// 假设满量程为 ±16g (LSB = 32768/16 = 2048)
float accel_x_g = (float)sensor_data.accel_x / 2048.0f;
```

### 角速度转换
```c
// 假设满量程为 ±2000°/s (LSB = 32768/2000 = 16.384)
float gyro_x_dps = (float)sensor_data.gyro_x / 16.384f;
```

## 扩展应用

- **平衡机器人**：使用 PID 算法控制电机平衡
- **手势识别**：通过模式识别实现简单的手势控制
- **运动追踪**：结合传感器融合算法进行姿态解算

## 常见问题

**Q：读取数据一直为 0？**
A：检查 I2C 是否正确初始化，MPU6050 是否接收到电源，AD0 引脚电平。

**Q：数据跳动很大？**
A：配置数字低通滤波器以减少噪声，检查供电是否稳定。

**Q：陀螺仪漂移严重？**
A：陀螺仪存在零偏，需要在上电时进行零偏校准。
